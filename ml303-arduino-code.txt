// ML-303 Bassline Arduino Control System
// Integrates LCD display, MIDI, and parameter monitoring

#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <MIDI.h>
#include <EEPROM.h>

// LCD Setup (address 0x27 is common for I2C backpacks)
LiquidCrystal_I2C lcd(0x27, 16, 2);

// MIDI Setup
MIDI_CREATE_DEFAULT_INSTANCE();

// Pin Definitions
const int POT_CUTOFF = A0;
const int POT_RESONANCE = A1;
const int POT_ENVMOD = A2;
const int POT_DECAY = A3;
const int BTN_RUN_STOP = 2;
const int BTN_PATTERN = 3;
const int GATE_IN = 4;
const int MIDI_IN_PIN = 12;
const int MIDI_OUT_PIN = 13;

// Pattern Storage
const int MAX_PATTERNS = 64;
const int PATTERN_LENGTH = 16;
struct Pattern {
  byte notes[PATTERN_LENGTH];
  byte accents[PATTERN_LENGTH];
  byte slides[PATTERN_LENGTH];
  byte tempo;
};

// Global Variables
Pattern patterns[MAX_PATTERNS];
int currentPattern = 0;
int currentStep = 0;
bool isRunning = false;
unsigned long lastStepTime = 0;
int tempo = 120; // BPM
int stepInterval = 60000 / (tempo * 4); // 16th notes

// Parameter values
int cutoff, resonance, envmod, decay;
int lastCutoff, lastResonance, lastEnvmod, lastDecay;

// Display modes
enum DisplayMode {
  MODE_PERFORMANCE,
  MODE_EDIT,
  MODE_SETTINGS
};
DisplayMode displayMode = MODE_PERFORMANCE;

void setup() {
  // Initialize pins
  pinMode(BTN_RUN_STOP, INPUT_PULLUP);
  pinMode(BTN_PATTERN, INPUT_PULLUP);
  pinMode(GATE_IN, INPUT);
  
  // Initialize LCD
  lcd.init();
  lcd.backlight();
  lcd.setCursor(0, 0);
  lcd.print("ML-303 BASSLINE");
  lcd.setCursor(0, 1);
  lcd.print("Initializing...");
  
  // Initialize MIDI
  MIDI.begin(MIDI_CHANNEL_OMNI);
  MIDI.setHandleNoteOn(handleNoteOn);
  MIDI.setHandleNoteOff(handleNoteOff);
  MIDI.setHandleControlChange(handleCC);
  MIDI.setHandleClock(handleClock);
  MIDI.setHandleStart(handleStart);
  MIDI.setHandleStop(handleStop);
  
  // Load patterns from EEPROM
  loadPatterns();
  
  delay(1000);
  updateDisplay();
}

void loop() {
  // Read buttons
  static unsigned long lastButtonCheck = 0;
  if (millis() - lastButtonCheck > 50) {
    checkButtons();
    lastButtonCheck = millis();
  }
  
  // Read pots
  static unsigned long lastPotRead = 0;
  if (millis() - lastPotRead > 20) {
    readPots();
    lastPotRead = millis();
  }
  
  // Handle sequencer timing
  if (isRunning && (millis() - lastStepTime >= stepInterval)) {
    advanceSequencer();
    lastStepTime = millis();
  }
  
  // Process MIDI
  MIDI.read();
  
  // Update display
  static unsigned long lastDisplayUpdate = 0;
  if (millis() - lastDisplayUpdate > 100) {
    updateDisplay();
    lastDisplayUpdate = millis();
  }
}

void checkButtons() {
  static bool lastRunStop = HIGH;
  static bool lastPattern = HIGH;
  
  bool runStop = digitalRead(BTN_RUN_STOP);
  bool pattern = digitalRead(BTN_PATTERN);
  
  // Run/Stop button
  if (runStop == LOW && lastRunStop == HIGH) {
    isRunning = !isRunning;
    if (isRunning) {
      currentStep = 0;
      MIDI.sendStart();
    } else {
      MIDI.sendStop();
    }
  }
  
  // Pattern button
  if (pattern == LOW && lastPattern == HIGH) {
    currentPattern = (currentPattern + 1) % MAX_PATTERNS;
    loadPattern(currentPattern);
  }
  
  lastRunStop = runStop;
  lastPattern = pattern;
}

void readPots() {
  cutoff = analogRead(POT_CUTOFF) >> 3;     // 0-127
  resonance = analogRead(POT_RESONANCE) >> 3;
  envmod = analogRead(POT_ENVMOD) >> 3;
  decay = analogRead(POT_DECAY) >> 3;
  
  // Send MIDI CC if values changed
  if (abs(cutoff - lastCutoff) > 1) {
    MIDI.sendControlChange(74, cutoff, 1); // Filter cutoff
    lastCutoff = cutoff;
  }
  if (abs(resonance - lastResonance) > 1) {
    MIDI.sendControlChange(71, resonance, 1); // Resonance
    lastResonance = resonance;
  }
  if (abs(envmod - lastEnvmod) > 1) {
    MIDI.sendControlChange(12, envmod, 1); // Env mod
    lastEnvmod = envmod;
  }
  if (abs(decay - lastDecay) > 1) {
    MIDI.sendControlChange(75, decay, 1); // Decay
    lastDecay = decay;
  }
}

void advanceSequencer() {
  // Send MIDI for current step
  byte note = patterns[currentPattern].notes[currentStep];
  byte accent = patterns[currentPattern].accents[currentStep];
  byte slide = patterns[currentPattern].slides[currentStep];
  
  if (note > 0) {
    int velocity = accent ? 127 : 80;
    MIDI.sendNoteOn(note, velocity, 1);
    
    // Handle slide by not sending note off immediately
    if (!slide) {
      MIDI.sendNoteOff(note, 0, 1);
    }
  }
  
  // Send clock
  MIDI.sendClock();
  
  // Advance step
  currentStep = (currentStep + 1) % PATTERN_LENGTH;
}

void updateDisplay() {
  switch (displayMode) {
    case MODE_PERFORMANCE:
      lcd.setCursor(0, 0);
      lcd.print("P:");
      lcd.print(currentPattern);
      lcd.print(" S:");
      if (currentStep < 10) lcd.print("0");
      lcd.print(currentStep);
      lcd.print(" ");
      lcd.print(isRunning ? "RUN " : "STOP");
      
      lcd.setCursor(0, 1);
      lcd.print("C:");
      lcd.print(cutoff);
      lcd.print(" R:");
      lcd.print(resonance);
      lcd.print(" ");
      lcd.print(tempo);
      lcd.print("BPM");
      break;
      
    case MODE_EDIT:
      // Edit mode display
      lcd.setCursor(0, 0);
      lcd.print("EDIT P:");
      lcd.print(currentPattern);
      lcd.print(" S:");
      lcd.print(currentStep);
      
      lcd.setCursor(0, 1);
      lcd.print("Note:");
      byte note = patterns[currentPattern].notes[currentStep];
      if (note > 0) {
        lcd.print(noteToString(note));
      } else {
        lcd.print("---");
      }
      break;
      
    case MODE_SETTINGS:
      // Settings display
      lcd.setCursor(0, 0);
      lcd.print("MIDI Ch: ");
      lcd.print(1); // Fixed for now
      
      lcd.setCursor(0, 1);
      lcd.print("Clock: INT");
      break;
  }
}

String noteToString(byte note) {
  const char* noteNames[] = {"C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"};
  int octave = (note / 12) - 1;
  int noteName = note % 12;
  return String(noteNames[noteName]) + String(octave);
}

// MIDI Handlers
void handleNoteOn(byte channel, byte pitch, byte velocity) {
  // Could trigger the ML-303 from external MIDI
}

void handleNoteOff(byte channel, byte pitch, byte velocity) {
  // Handle note off
}

void handleCC(byte channel, byte number, byte value) {
  // Map CC to parameters
  switch (number) {
    case 74: // Filter cutoff
      // Would need DAC to send CV to ML-303
      break;
    case 71: // Resonance
      break;
    case 12: // Env mod
      break;
    case 75: // Decay
      break;
  }
}

void handleClock() {
  // Sync to external clock if in external sync mode
}

void handleStart() {
  isRunning = true;
  currentStep = 0;
}

void handleStop() {
  isRunning = false;
}

// Pattern storage functions
void loadPatterns() {
  // Initialize with some default patterns
  // In real implementation, load from EEPROM
  for (int p = 0; p < MAX_PATTERNS; p++) {
    for (int s = 0; s < PATTERN_LENGTH; s++) {
      patterns[p].notes[s] = 0;
      patterns[p].accents[s] = 0;
      patterns[p].slides[s] = 0;
    }
    patterns[p].tempo = 120;
  }
  
  // Example pattern (classic 303 pattern)
  patterns[0].notes[0] = 36; // C2
  patterns[0].notes[4] = 36;
  patterns[0].notes[8] = 39; // Eb2
  patterns[0].notes[12] = 36;
  patterns[0].accents[0] = 1;
  patterns[0].accents[8] = 1;
}

void loadPattern(int patternNum) {
  // Load pattern from EEPROM
  // Update tempo
  tempo = patterns[patternNum].tempo;
  stepInterval = 60000 / (tempo * 4);
}

void savePattern(int patternNum) {
  // Save pattern to EEPROM
  int baseAddr = patternNum * sizeof(Pattern);
  EEPROM.put(baseAddr, patterns[patternNum]);
}